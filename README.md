# 1C-OData AI Bridge (RAG + Tool Calling)

Интеллектуальный шлюз для взаимодействия с системой **1С:Предприятие 8.3** через OData. Проект реализует архитектуру **AI-Agent**, которая преобразует неструктурированные запросы пользователя в точные вызовы OData API.

## Предупреждение!
**_Проект является R&D исследованием (MVP). Целью была проверка гипотезы интеграции LLM и 1С, а не написание идеального высоконагруженного сервиса. Критика архитектуры приветствуется._**

## Основная концепция (R&D опыт)
В ходе разработки был осуществлен переход от «наивного чат-бота» к системе с предсказуемым результатом.
*   **ИИ как Навигатор**: Используется для распознавания намерений и семантического поиска по метаданным.
*   **Java**: Обработка данных и итоговый вывод вынесены из области генерации текста ИИ в строгий программный код. Это исключает галлюцинации в названиях и гарантирует 100% точность ИНН и сумм.

## Технологический стек
*   **Java 21 / Spring Boot 4.0** (Spring AI)
*   **LLM (через Ollama):** mxbai-embed-large / llama3.1
*   **Vector DB:** PostgreSQL + **pgvector** (хранение семантических индексов таблиц и полей 1С)
*   **Интеграция:** OData (REST API 1С)

## Архитектура системы
Процесс обработки запроса разделен на три изолированных этапа:

1.  **Классификация (Semantic Search):** Поиск технических имен таблиц (напр. `Catalog_Контрагенты`) в векторной базе на основе смысла вопроса пользователя.
2.  **Формирование контекста:** Динамическая подгрузка описания полей (RAG) только для выбранной сущности.
3.  **Исполнение (Tool Calling):**
   *   Модель формирует параметры (лимиты, фильтры). Заложена возможность расширенной фильтрации, для этого снимите комментарий в AIService.getSmartResponse и добавьте {fieldsContext} в системный контекст.
   *   Вызывается Java-инструмент `executeSmartQuery`.
   *   Система возвращает **сырой JSON** напрямую из 1С, обеспечивая достоверность данных.

```mermaid
graph LR
    accTitle: "Схема работы приложения"
    %% Стилизация
    classDef danger fill:#f96,stroke:#333,stroke-width:2px;
    classDef gateway fill:#dfd,stroke:#333,stroke-width:2px;
    classDef storage fill:#f5f5f5,stroke:#333;

    U["Пользователь"] -->|"1. Запрос"| G("AI-Шлюз Java")
    
    %% Блок RAG
    G -->|"2. Текст"| E[mxbai-embed]
    E -->|"3. Вектор"| G
    G -->|"4. Поиск"| V[(Vector DB)]
    V -->|"5. Сущности"| G

    %% Блок LLM и OData
    G -->|"6. Промпт + Сущности"| L1["LLM: План"]
    L1 -->|"7. Tool Call"| G
    G -->|"8. GET"| O[["1C: OData"]]
    O -->|"9. JSON"| G
  
    G -->|"10. JSON"| U

    %% Применение стилей
    class G gateway;
    class V,O storage;
 ```   
_Примечание к схеме:_  
_На представленной схеме отображен текущий рабочий процесс. При изучении исходного кода в репозитории вы заметите, 
что механизм получения контекста полей реализован, но на данный момент закомментирован.
Это осознанное решение: сейчас данный функционал является технологическим рудиментом от более ранних этапов разработки. 
Я решил не удалять этот код, а оставить его в качестве готового задела на будущее.   
Архитектура проекта позволяет 
в любой момент активировать этот слой для реализации сложной фильтрации (поиск по конкретным реквизитам, ИНН или датам), 
когда в этом возникнет реальная бизнес-необходимость.   
Главный фокус текущей версии — максимально быстрая и надежная навигация к данным с гарантией их достоверности на финальном шаге._

## Установка и запуск

### 1. Настройка окружения
*   Установите **PostgreSQL** 16+ и расширение **pgvector**:
  * sudo apt install postgresql-16
  * sudo apt install postgresql-16-pgvector
  * создайте базу данных CREATE DATABASE odata_ai_bridge;
  * переключитесь в эту базу \c odata_ai_bridge
  * создайте расширение CREATE EXTENSION vector;
*   Установите **Ollama** и загрузите модель: `ollama run llama3.1`.
*  Перед выполнением SMART-запросов проиндексируете метаданные 1С.

### 2. Конфигурация (application.yml)
Для исключения галлюцинаций и работы с большими объектами 1С используются строго определенные параметры:
```yaml
spring:
  ai:
    ollama:
      chat:
        options:
          temperature: 0.0  # Отключение фантазии модели
          num-ctx: 16384   # Увеличенное окно контекста для JSON
```

### 3. API Reference
Все запросы выполняются к базовому адресу: http://localhost:8080

|Метод|	Эндпоинт	| Параметры       | 	Описание                                                                                        |
|-|-|-----------------|--------------------------------------------------------------------------------------------------|
|GET |/api/ai/simple | prompt (string) | Простой запрос к ИИ (без доступа к данным 1С)                                                    |
|GET |/api/ai/ask | prompt (string) | Smart-запрос: поиск данных в 1С или вызов справки                                                |
|GET |/api/admin/reindex | -               | Ручной запуск переиндексации метаданных 1С в векторную БД. При переиндексации таблица очищается. |
			
**Примеры использования:**   
- **Запрос данных:**   
   GET /api/ai/ask?prompt=Покажи 5 складов   
   Возвращает: JSON-массив из 1С.
- **Запрос справки:**    
   GET /api/ai/ask?prompt=Что ты умеешь?    
   Возвращает: Список доступных сущностей (Markdown).
- **Переиндексация:**   
   GET /api/admin/reindex
   Возвращает: Статус завершения процесса.

_**Примечание по безопасности:**_   
Метод /api/admin/reindex намеренно реализован через GET для упрощения ручного вызова из адресной строки браузера при тестировании.   
Я осознаю, что согласно стандартам REST, операции, изменяющие состояние, должны использовать метод POST, для Production-версии требуется доработка.

## Лицензия
Проект распространяется под лицензией [MIT](LICENSE) (на английском языке).